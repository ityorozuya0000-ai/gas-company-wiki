<script>
    /**
     * State Management
     */
    const state = {
        pages: [],
        pageCache: {}, // Memory cache for page details
        currentPage: null,
        route: 'home', // home, view, edit
        params: {},
        editorInstance: null
    };

    /**
     * Router & Navigation
     */
    function navigate(route, params = {}) {
        state.route = route;
        state.params = params;
        render();
    }

    function handleHashChange() {
        const hash = window.location.hash.slice(1); // #view/123 -> view/123
        if (!hash) {
            navigate('home');
            return;
        }

        const [route, id] = hash.split('/');
        navigate(route, { id });
    }

    window.addEventListener('hashchange', handleHashChange);

    /**
     * API Wrappers
     */
    const api = {
        getPages: () => new Promise((resolve, reject) => {
            google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .apiGetPages();
        }),
        getPage: (id) => new Promise((resolve, reject) => {
            google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .apiGetPage(id);
        }),
        savePage: (data) => new Promise((resolve, reject) => {
            google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .apiSavePage(data);
        }),
        searchPages: (q) => new Promise((resolve, reject) => {
            google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .apiSearchPages(q);
        }),
        uploadFile: (fileData) => new Promise((resolve, reject) => {
            google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .apiUploadFile(fileData);
        })
    };

    /**
     * Setup & Initialization
     */
    document.addEventListener('DOMContentLoaded', async () => {
        // Check initial hash
        handleHashChange();

        // Clean URL hash on load if needed, or trigger initial load
        if (state.route === 'home') {
            loadPages();
        }
    });

    async function loadPages() {
        // Try to load from LocalStorage first for speed
        const cached = localStorage.getItem('company_wiki_pages');
        if (cached) {
            try {
                state.pages = JSON.parse(cached);
                updateSidebarTags();
                if (state.route === 'home') renderHome();
            } catch (e) {
                console.error('Cache parse error', e);
            }
        } else {
            showLoader(true);
        }

        try {
            // Background fetch to ensure freshness
            const freshPages = await api.getPages();

            // Check if data actually changed to avoid unnecessary re-renders (simple JSON check)
            if (JSON.stringify(freshPages) !== JSON.stringify(state.pages)) {
                state.pages = freshPages;
                localStorage.setItem('company_wiki_pages', JSON.stringify(freshPages));
                updateSidebarTags();
                if (state.route === 'home') renderHome();
            }
        } catch (err) {
            console.error(err);
            if (!cached) alert('ãƒšãƒ¼ã‚¸ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
        } finally {
            showLoader(false);
        }
    }

    function updateSidebarTags() {
        // Extract all tags
        const tagCounts = {};
        state.pages.forEach(p => {
            if (!p.tags) return;
            p.tags.split(',').forEach(t => {
                const tag = t.trim();
                if (tag) tagCounts[tag] = (tagCounts[tag] || 0) + 1;
            });
        });

        // Sort by count
        const sortedTags = Object.keys(tagCounts).sort((a, b) => tagCounts[b] - tagCounts[a]);

        const nav = document.querySelector('.sidebar nav');
        if (!nav) return;

        // Keep Home, remove others (if any dynamic ones existed)
        let tagSection = document.getElementById('sidebar-tags');
        if (!tagSection) {
            tagSection = document.createElement('div');
            tagSection.id = 'sidebar-tags';
            tagSection.style.marginTop = '2rem';
            nav.parentNode.insertBefore(tagSection, nav.nextSibling);
        }

        tagSection.innerHTML = `
            <div style="font-size:0.85rem; font-weight:600; color:var(--text-sub); margin-bottom:0.5rem;">ã‚¿ã‚°ä¸€è¦§</div>
            <div style="display:flex; flex-wrap:wrap; gap:0.5rem;">
                ${sortedTags.map(tag => `
                    <span class="tag clickable" onclick="filterByTag('${tag}')">#${tag} (${tagCounts[tag]})</span>
                `).join('')}
                ${sortedTags.length === 0 ? '<span style="font-size:0.8rem; color:#9ca3af;">ã‚¿ã‚°ãªã—</span>' : ''}
            </div>
        `;
    }

    /**
     * Rendering Logic
     */
    function render() {
        const app = document.getElementById('main-container');
        app.innerHTML = ''; // Clear

        switch (state.route) {
            case 'home':
                renderHome();
                break;
            case 'view':
                renderView(state.params.id);
                break;
            case 'edit':
                renderEditor(state.params.id);
                break;
            default:
                renderHome();
        }
    }

    function renderHome() {
        const container = document.getElementById('main-container');

        // Search Bar
        const searchHtml = `
    <div class="search-box" style="display:flex; align-items:center; gap:10px;">
      <div style="position:relative; flex-grow:1;">
        <span class="search-icon">ğŸ”</span>
        <input type="text" id="search-input" class="search-input" placeholder="ãƒšãƒ¼ã‚¸ã‚’æ¤œç´¢... (ã‚¿ã‚°ã‚¯ãƒªãƒƒã‚¯ã§çµã‚Šè¾¼ã¿)" onkeyup="handleSearch(this.value)" style="width:100%; box-sizing:border-box;">
      </div>
      <button class="btn-secondary" onclick="triggerImport()" title="Markdownãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ" style="white-space:nowrap;">ğŸ“¥ Import</button>
    </div>
  `;

        // Page List
        const listHtml = `
    <div id="page-list" class="fade-in">
      ${renderPageListItems(state.pages)}
    </div>
  `;

        container.innerHTML = `<h1>ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹</h1>${searchHtml}${listHtml}`;
    }

    function renderPageListItems(pages) {
        if (pages.length === 0) {
            return '<p style="text-align:center; color:var(--text-sub)">ãƒšãƒ¼ã‚¸ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ–°è¦ä½œæˆã—ã¦ã¿ã¾ã—ã‚‡ã†ï¼</p>';
        }

        return pages.map(page => `
    <div class="nav-item-wrapper" style="display:flex; align-items:flex-start; margin-bottom:0.5rem; background:white; border-radius:var(--radius-md); border:1px solid transparent; transition:all 0.2s;">
        <div class="nav-item" onclick="window.location.hash = '#view/${page.id}'" style="flex-grow:1; margin:0; border:none; background:none;">
          <div>
            <div style="font-weight:600; color:var(--text-main)">${page.title}</div>
            <div style="font-size:0.8rem; color:var(--text-sub)">
              ${new Date(page.updated_at).toLocaleDateString()} æ›´æ–°è€…: ${page.author_email}
            </div>
          </div>
        </div>
        <div style="padding:0.75rem;">
          ${renderClickableTags(page.tags)}
        </div>
    </div>
  `).join('');
    }

    function renderClickableTags(tagsStr) {
        if (!tagsStr) return '<span class="tag clickable" onclick="filterByTag(\'ä¸€èˆ¬\')">ä¸€èˆ¬</span>';

        return tagsStr.split(',')
            .map(t => t.trim())
            .filter(t => t)
            .map(tag => {
                // Escape single quotes for onclick attribute
                const safeTag = tag.replace(/'/g, "\\'");
                return `<span class="tag clickable" onclick="filterByTag('${safeTag}')">${tag}</span>`;
            })
            .join(' ');
    }

    function filterByTag(tag) {
        const input = document.getElementById('search-input');
        if (input) {
            input.value = tag;
            // Immediate search with loader
            handleSearch(tag, true);
        }
    }

    let searchTimeout = null;
    async function handleSearch(query, immediate = false) {
        // Debounce for keyup (300ms) unless immediate (tag click)
        if (!immediate) {
            if (searchTimeout) clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => performSearch(query), 300);
        } else {
            performSearch(query);
        }
    }

    async function performSearch(query) {
        // UI Feedback - visual indicator in the list area
        const listContainer = document.getElementById('page-list');
        if (!listContainer) return;

        // If purely loading locally, it might be fast, but server roundtrip takes time.
        // We can use a small opacity change or mini-spinner.
        // For tag click (immediate), let's use global loader or just opacity text.
        listContainer.style.opacity = '0.5';

        try {
            const results = await api.searchPages(query);
            state.pages = results;

            // Update list
            listContainer.innerHTML = renderPageListItems(results);
        } catch (e) {
            console.error(e);
            listContainer.innerHTML = '<p style="color:red; text-align:center;">æ¤œç´¢ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ</p>';
        } finally {
            listContainer.style.opacity = '1';
        }
    }

    async function renderView(id) {
        const container = document.getElementById('main-container');

        // Check Memory Cache
        if (state.pageCache[id]) {
            renderViewContent(state.pageCache[id]);
            return;
        }

        showLoader(true);
        try {
            const page = await api.getPage(id);
            if (!page) {
                container.innerHTML = '<p>ãƒšãƒ¼ã‚¸ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚</p>';
                return;
            }

            // Store in Cache
            state.pageCache[id] = page;
            renderViewContent(page);
        } catch (err) {
            container.innerHTML = '<p class="text-red-500">ãƒšãƒ¼ã‚¸ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</p>';
        } finally {
            showLoader(false);
        }
    }

    function renderViewContent(page) {
        const container = document.getElementById('main-container');

        let contentHtml = '';
        if (page.format === 'markdown') {
            contentHtml = marked.parse(page.content);
        } else {
            contentHtml = page.content;
        }

        // Anti-XSS Sanitization
        if (window.DOMPurify) {
            contentHtml = DOMPurify.sanitize(contentHtml, {
                ADD_TAGS: ['video'], // Allow video tags
                ADD_ATTR: ['src', 'controls', 'style'] // Allow controls/styles for video
            });
        }

        container.innerHTML = `
      <div class="fade-in">
        <div class="page-meta">
           <span>ä½œæˆæ—¥: ${new Date(page.created_at).toLocaleDateString()}</span>
           <span>ä½œæˆè€…: ${page.author_email}</span>
           ${page.tags ? `<span class="tag">${page.tags}</span>` : ''}
        </div>
        
        <div class="page-header">
            <h1 style="margin:0;">${page.title}</h1>
            <div class="page-actions">
               <button class="btn-secondary" onclick="window.location.hash = '#home'">ä¸€è¦§ã¸</button>
               <button class="btn-secondary" onclick="exportMarkdown('${page.id}')">Export</button>
               <button class="btn-secondary" style="background:var(--primary); color:white; border:none;" onclick="window.location.hash = '#edit/${page.id}'">ç·¨é›†</button>
            </div>
        </div>

        <div class="page-content ql-editor" style="padding:0; margin-top:2rem; border-top:1px solid var(--border); padding-top:2rem;">${contentHtml}</div>
      </div>
    `;
    }

    async function renderEditor(id) {
        const container = document.getElementById('main-container');
        showLoader(true);

        let page = { title: '', content: '', format: 'html', tags: '' };

        if (id && id !== 'new') {
            try {
                page = await api.getPage(id);
            } catch (e) {
                alert('ç·¨é›†ã™ã‚‹ãƒšãƒ¼ã‚¸ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                return;
            }
        }

        container.innerHTML = `
    <div class="fade-in">
       <h1>${id ? 'ãƒšãƒ¼ã‚¸ç·¨é›†' : 'æ–°è¦ãƒšãƒ¼ã‚¸ä½œæˆ'}</h1>
       
       <div class="input-group">
         <label class="input-label">ã‚¿ã‚¤ãƒˆãƒ«</label>
         <input type="text" id="edit-title" class="text-input" value="${page.title}" placeholder="ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›">
       </div>
       
       <div class="input-group">
         <label class="input-label">ã‚¿ã‚° (ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š)</label>
         <input type="text" id="edit-tags" class="text-input" value="${page.tags}" placeholder="ä¾‹: äººäº‹, ãƒãƒ‹ãƒ¥ã‚¢ãƒ«, æŠ€è¡“">
       </div>
       
       <div class="editor-toolbar">
         <label class="input-label" style="margin:0">å½¢å¼:</label>
         <div class="mode-switch">
           <button class="mode-btn ${page.format === 'html' ? 'active' : ''}" onclick="setEditorMode('html')">ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆ</button>
           <button class="mode-btn ${page.format === 'markdown' ? 'active' : ''}" onclick="setEditorMode('markdown')">Markdown (MD)</button>
         </div>
         <span style="flex-grow:1"></span>
         <button class="btn-secondary" onclick="insertImage()">ğŸ“· ç”»åƒ/å‹•ç”»ã‚’æŒ¿å…¥</button>
       </div>
       
       <!-- Rich Text -->
       <div id="quill-wrapper" class="quill-wrapper ${page.format === 'html' ? 'active' : ''}">
         <div id="editor-container" style="height:400px; background:white;"></div>
       </div>
       
       <!-- Markdown -->
       <textarea id="markdown-editor" class="markdown-editor ${page.format === 'markdown' ? 'active' : ''}" placeholder="# ã“ã“ã«Markdownã‚’å…¥åŠ›...">${page.content}</textarea>
       
       <div class="page-actions">
         <button class="new-page-btn" style="width:auto; margin:0;" onclick="savePage('${id || ''}')">ä¿å­˜ã™ã‚‹</button>
         <button class="btn-secondary" onclick="window.history.back()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
       </div>
    </div>
  `;

        showLoader(false);

        // Always initialize Quill because internal HTML was rewritten
        // We don't rely on cached instance for DOM connection
        var quill = new Quill('#editor-container', {
            theme: 'snow',
            modules: {
                toolbar: [
                    [{ 'header': [1, 2, 3, false] }],
                    ['bold', 'italic', 'underline', 'strike'],
                    ['blockquote', 'code-block'],
                    [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                    [{ 'color': [] }, { 'background': [] }],
                    ['clean']
                ]
            }
        });

        // Set content
        if (page.format === 'html') {
            quill.root.innerHTML = page.content;
        }

        state.editorInstance = quill;
        state.editMode = page.format;
    }

    function setEditorMode(mode) {
        state.editMode = mode;

        // UI Update
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        if (mode === 'html') {
            document.querySelector('.mode-btn:first-child').classList.add('active');
            document.getElementById('quill-wrapper').classList.add('active');
            document.getElementById('markdown-editor').classList.remove('active');
        } else {
            document.querySelector('.mode-btn:last-child').classList.add('active');
            document.getElementById('quill-wrapper').classList.remove('active');
            document.getElementById('markdown-editor').classList.add('active');
        }
    }

    function insertImage() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*,video/*'; // Accept video too

        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            showLoader(true);

            const reader = new FileReader();
            reader.onload = async function (evt) {
                const base64 = evt.target.result.split(',')[1];
                const data = {
                    name: file.name,
                    type: file.type,
                    base64: base64
                };

                try {
                    const result = await api.uploadFile(data);

                    // Insert into editor
                    if (state.editMode === 'html') {
                        const range = state.editorInstance.getSelection(true);
                        if (file.type.startsWith('video')) {
                            // Video tag for HTML
                            state.editorInstance.clipboard.dangerouslyPasteHTML(range.index, `<video src="${result.url}" controls style="max-width:100%"></video>`);
                        } else {
                            // Image
                            state.editorInstance.insertEmbed(range.index, 'image', result.url); // Use direct view URL
                        }
                    } else {
                        const textarea = document.getElementById('markdown-editor');
                        const insertText = file.type.startsWith('video')
                            ? `\n<video src="${result.url}" controls></video>\n`
                            : `\n![${file.name}](${result.url})\n`;
                        textarea.value += insertText;
                    }
                } catch (err) {
                    alert('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + err);
                } finally {
                    showLoader(false);
                }
            };
            reader.readAsDataURL(file);
        };

        input.click();
    }

    // --- Import / Export Functions ---

    function triggerImport() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.md,.markdown,.txt';
        input.onchange = (e) => handleImport(e.target.files[0]);
        input.click();
    }

    function handleImport(file) {
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
            const content = e.target.result;
            // Simple parsing: Title is filename (without ext) or first h1
            let title = file.name.replace(/\.[^/.]+$/, "");
            let body = content;

            // Try to extract title from # Title
            const titleMatch = content.match(/^#\s+(.+)$/m);
            if (titleMatch) {
                title = titleMatch[1];
            }

            if (!confirm(`ã€Œ${title}ã€ã¨ã—ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã‹ï¼Ÿ`)) return;

            showLoader(true);
            try {
                await api.savePage({
                    id: null,
                    title: title,
                    content: body,
                    format: 'markdown', // Always markdown for import
                    tags: 'Imported'
                });
                alert('ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸï¼');
                loadPages();
            } catch (err) {
                alert('ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: ' + err);
            } finally {
                showLoader(false);
            }
        };
        reader.readAsText(file);
    }

    async function exportMarkdown(id) {
        showLoader(true);
        try {
            const page = await api.getPage(id);
            if (!page) throw new Error('Page not found');

            let content = page.content;

            if (page.format === 'html') {
                if (!confirm('ã“ã®ãƒšãƒ¼ã‚¸ã¯ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆ(HTML)ã§ã™ã€‚HTMLã®ã¾ã¾ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã™ã‹ï¼Ÿ\n(Markdownãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜ã•ã‚Œã¾ã™ãŒã€ä¸­èº«ã¯HTMLã‚¿ã‚°ã‚’å«ã¿ã¾ã™)')) {
                    return;
                }
            }

            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${page.title}.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

        } catch (e) {
            alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå¤±æ•—: ' + e);
        } finally {
            showLoader(false);
        }
    }

    async function savePage(id) {
        const title = document.getElementById('edit-title').value;
        const tags = document.getElementById('edit-tags').value;

        let content = '';
        if (state.editMode === 'html') {
            content = state.editorInstance.root.innerHTML;
        } else {
            content = document.getElementById('markdown-editor').value;
        }

        if (!title) return alert('ã‚¿ã‚¤ãƒˆãƒ«ã¯å¿…é ˆã§ã™');

        showLoader(true);
        try {
            await api.savePage({
                id: id === 'new' ? null : id,
                title,
                content,
                format: state.editMode,
                tags
            });

            // Invalidate Caches
            localStorage.removeItem('company_wiki_pages');
            if (id && id !== 'new') delete state.pageCache[id];

            alert('ä¿å­˜ã—ã¾ã—ãŸï¼');
            window.location.hash = '#home';
            loadPages(); // Refresh list
        } catch (e) {
            alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e);
        } finally {
            showLoader(false);
        }
    }

    /**
     * UI Helpers
     */
    function showLoader(show) {
        let loader = document.getElementById('global-loader');
        if (!loader) {
            loader = document.createElement('div');
            loader.id = 'global-loader';
            loader.className = 'loader-overlay hidden';
            loader.innerHTML = '<div class="spinner"></div>';
            document.body.appendChild(loader);
        }

        if (show) loader.classList.remove('hidden');
        else loader.classList.add('hidden');
    }
</script>